# This builds the shiny app for creating our CAIN data set.
# Stefan Stojkovic
# Last package update: October 19, 2023


# 0 Preparations ####

# 0.1 Packages ####

library(shiny)
library(shinymanager)
library(shinyjs)
library(dplyr)
library(readr)
library(rdrop2)
library(jpeg)
library(leaflet)
library(stringr)
library(SUNGEO)

# 0.2 Dropbox ####

# Log in to dropbox: Please run the following two lines of codes which are commented out only once!
# Update: This will only generate a token valid for a couple of hours as of mid 2023.
# See below for comments on how to address this.


#token <- drop_auth(new_user=T)
#saveRDS(token, file="/home/bdellasala/Dropbox/22-2-InterwarViolence/shiny_generalapp/data_input/token.rds")
token <- readRDS("data_input/token.rds")

# Notes for future apps: tokens need to be created by the future host of the app and link to their respective Dropbox. 
# There are several different tokens; the standard one is a token that becomes invalid within a few hours.
# Please make sure to use a token that is either automatically renewed after it became inactive, 
# or to use a token that remains valid for the period of time the app is in use.


# Dropbox paths
#Path to dropbox for final data:
dropboxPath_input <- "22-2-InterwarViolence/shiny_generalapp/data_input"
dropboxPath_final <- "22-2-InterwarViolence/shiny_generalapp/data_output/raw"
# Paths are once defined in the beginning, and referenced in the remaining code so that when
# paths change, we only need to change them in one line of code, and not several lines.

# Entry fields to be stored in final data:
fieldsAll <- c(#"eventID","coder",
               #"country_coded","newspaper",
               "year","month","day","art_select",
               "novio","missinginfo","outside",
               "country","region","town","town_locality","street","mapfine",#"town_ln","town_lat",
               "day_start","month_start","year_start","start_date_prec",
               "showEndDate",
               "day_end","month_end","year_end","end_date_prec",
               "two_sided",
               "actor_a_group","actor_a","actor_a_other",
               "actor_b_group","actor_b","actor_b_other",
               "deaths_cat","deaths","injured_cat","injured",
               "comments"
)
# This is a list of input values that are to be saved in the final data set.
# By input values, I mean the values that we can extract in the server function by writing input$...
# These input values are generated by the user by typing in stuff or clicking on buttons.


# 1 Load data ####
# Here, we load and define data that the shiny app needs.
newspaper_list<-drop_read_csv("22-2-InterwarViolence/shiny_generalapp/data_input/newspaper_list.csv",dtoken=token)

# Credentials for logging in:
credentials <- data.frame(
  coderID=c(rep("coder-",4),paste0("coder-",1:10)),
  user=c("Nils","Bruno","Stefan","Lea",
         "Angela","Esmirna","Franziska","Federica","Oliver",
         "Sophie","Vincent","Jani","Leander","Michaela"),
  password=c("JZA_21Nov25","NCP_21Nov25","KZA-SD_21Nov25","Soc_21Nov25",
             "AJ_22June15","SDM&L_21Nov25","PNRE_21Nov25","4mWYvt","OLK_21Feb52",
             "ATuX2U","NZR_21Nov25","PUP_21Nov25","BBB_21Nov25","G5wF27"),
  stringsAsFactors = F)


# NOTE: This is now done for each RA separately below in the server function based on the coderAssign data set loaded above.

# The list of countries we are interested in in our project:
countryList <- c("Austria","Belgium",
                 "Czechoslovakia","Denmark",
                 "Estonia","Finland",
                 "France","Germany",
                 "Greece","Iceland","Ireland",
                 "Italy","Latvia",
                 "Lithuania","Luxembourg",
                 "Netherlands","Norway",
                 "Poland","Portugal",
                 "San Marino","Spain",
                 "Sweden","Switzerland",
                 "United Kingdom",
                 "Yugoslavia","Other")

# The list of potential actors to code and their respective actor group/category:
# First, list all file names in the data_input folder on Dropbox:
actorListList <- drop_dir(dropboxPath_input)
actorListList <- actorListList[grepl(pattern="actorList", x=actorListList$name),] # Select those with "actorList" in their name.
actorListList <- actorListList[order(actorListList$name, decreasing = T),] # Order them so that the newest comes first.
actor_list <- drop_read_csv(file=actorListList$path_display[1], # Download the csv file into a data frame actorListExt.
                              dest=tempdir(),
                              dtoken=token)
rm(actorListList) # Remove unnecessary objects.
# Here, we load the data directly from the Dropbox, because below in the script, this list gets updated and
# saved under a new name (with respective date) once coders enter new groups to code. With every new instance, 
# coders will have an updated list of actors available to select from.



# 2 User interface ####
# This section defines the user interface.
# Be reminded that the user interface describes the design, but not the functionality of the elements shown in the app.
# The functionality of each of the elements is defined below in the server function.

ui <- secure_app(fluidPage( 
  # secure_app adds the log-in feature, and fluidPage opens the visual room of the app and 
  # makes it adaptable to different window sizes.
  
  useShinyjs(),
  # Indicate, that we also need to use JavaScript for some features, e.g. the hide() and show() functions.
  
  # Theme and general layout
  theme=bslib::bs_theme(bootswatch = "spacelab"),
  
  # Application title
  titlePanel("Political violence in democratic Europe during the interwar period"),
  
  # 2.1 Intro ####
  
  # This is the first introductory text within the html section "intro":
  # Use div(id="...",...) to structure your app in a nice way, and to hide and show specific elements of it.
  div(id="intro",
      p("With this app, we code whether a list of articles describes events of political violence in democracies in Europe between 01 January 1919 and 31 August 1939."),
      p("Please, first select your assigned country, then the newspaper you are coding, then the date of the article"),
      p("Before saving a final version of the event you coded, please use the \"Check data consistency\" button below and correct potential mistakes."),
      p(strong("The app will refresh if you remain inactive on this page for about 10 minutes! Please make sure to save some notes outside the app or to save your finished coding before that happens."))
  ),
  
  # 2.2 Newspaper article and map ####
  
  
  fluidRow(
    column(12,
           div(id="country_assigned",
           h4("Country Selection"),
           # Under this headline, we have a lot of app functions related to the article itself that is relevant before the coders fill in
           # relevant information for each of the variables we are interested in.
           selectInput("country_list",
                       label="First, please select the country you are coding:",
                        choices=c("None selected",countryList),
                        selected="None selected"),
           p(textOutput("country_coded"))
           )),
  
  fluidRow(
    column(8, # There is a space of 12 to be distributed among different columns; this one receives 8.
           div(id="article",
               h4("Newspaper selection"),
               selectInput("newspaper_select", 
                              label="First, please select a newspaper:",
                              choices=c("None selected"),
                              selected="None selected"),
               p(textOutput("newspaper")) # This is defined later in the server function.
           )),
    column(4, # There is a space of 12 to be distributed among different columns; this one receives 4.
           div(id="map",
               h4("Map of Europe"),
               leafletOutput("europe"))) # This is defined later in the server function.
  ),
  
  fluidRow(
    column(12,
         h4("Date of the Article"),
         div(id="article_date",
             
             # Some introductory text:
             p("Add the date in which the article was published"),
             
             hidden( # This is only shown when coders select "Unknown" for the year (see server function for this functionality):
               div(id="dateMis",
                   h4("If it is unclear in which year the article was written, please tick the box for too much missing information above, save and proceed."))
             ),
             hidden( # This is only shown when coders select "Outside period" for the year (see server function for this functionality):
               div(id="dateOut",
                   h4("If the article date was published outside our period of interest (see above) and do not refer to an event occuring in the time-period, please save and proceed with next event or text."))
             ),
             
             # Entry variables:
             selectInput("year", "Year", c("None selected","Outside period","Unknown",as.character(1919:1939))),
             selectInput("month", "Month", c("None selected","Unknown","1: January","2: February","3: March","4: April","5: May",
                                                         "6: June","7: July","8: August","9: September","10: October",
                                                         "11: November","12: December")),
             selectInput("day", "Day", c("None selected","Unknown",paste0("0",as.character(1:9)),as.character(10:31)))))),
  
  fluidRow(
    column(12,
           h4("Article to code"),
           div(id="article_number",
               p("Add the number of the article"),
               hidden( # This is only shown when coders select 0 for the article (see server function for this functionality):
                 div(id="artMis",
                     h4("Select the number of the article"))
               ),
               selectInput("art_select", "Article",as.character(0:100))
           ))
  ),
  
  
  fluidRow(
    column(12,
           h4("Information on newspaper article"),
           # Under this headline, we have a lot of app functions related to the article itself that is relevant before the coders fill in
           # relevant information for each of the variables we are interested in.
           
           div(id="noviolence",
               checkboxInput("novio",
                             strong("This article does not mention any political violence"),
                             value=F)), # This is to save whether the article mentions political violence.
           div(id="noinfobutton",
               checkboxInput("missinginfo",
                             strong("This article does not mention enough information to be coded (e.g. actor, year or place missing)."),
                             value=F)), # This is to save whether the article mentions enough information.
           div(id="outsidecountry",
               checkboxInput("outside",
                             strong("This article mentions an event happening outside of the country of interest"),
                             value=F)) # This is to save whether the article mentions an event outside of the country of interest.
           )), 
  
  
  # 2.3 Coding tasks ####
  
  fluidRow( # This spans around all coding sub-sections of the app, each allocated a space of 3.
    
    # 2.3.1 Location ####
    
    column(3,
           h4("Location"),
           
           div(id="location",
               
               # These two elements are hidden until something (defined below) happens:
               hidden( # Only show if coders select "Unknown" as country, see server function for the functionality itself.
                 div(id="noinfosec",
                     h4("If it is unclear in which country the event took place, please tick the box for too much missing information above, save and proceed."))
               ),
               hidden( # Only show if coders select any country but Ireland or the UK, see server function for the functionality itself.
                 div(id="dontcode",
                     h4("Please do not code the rest of the information but only the country if the event did not take place in the UK."))
               ),
               # Entry variables: 
               selectInput("country", "Country (borders as of today)",
                           choices=c("None selected","Not mentioned",countryList), 
                           selected="None selected"),
               textInput("region","Region (e.g. state or district)",value=NA,placeholder="leave empty if NA"),
               textInput("town","Borough, town, village or city (formate: borough, town)",value=NA,placeholder="leave empty if NA"),
               textInput("town_locality", "Area or locality (e.g. squares or buildings)",value=NA,placeholder="leave empty if NA"),
               textInput("street","Street",value=NA,placeholder="leave empty if NA"),
               
               # This is the old stuff from back than when the map functionality did not work:
               #p("If you feel uncertain about the precision of the information you provided, please consider looking for latitude and longitude on", strong("wikipedia.org"), ". Please only use the decimal formate (e.g. 50.936389, 6.952778, meaning lat, long)."),
               #textInput("lat","Latitude",value=NA,placeholder = "leave empty if NA"),
               #textInput("long","Longitude",value=NA,placeholder="leave empty if NA"),
               
               # Show a button to click on when variables above are specified:
               actionButton("showmap","Show on map", class = "btn-primary"),
               
               # Explain how to proceed when the town is (not) correctly marked:
               checkboxInput("mapfine","Tick if town is correctly marked"),
               p("If",strong("the town is not correctly marked"),", try specifying the name by adding additional information, e.g. instead of \"Westhill\", try \"Westhill, Northern Ireland\", if you were looking for Westhill in NI rather than Westhill in Scotland. Sometimes, articles provide information on the county that can be added. Otherwise, a Google search might help.")
           )
    ),
    
    # 2.3.2 Dates ####
    
    column(3,
           h4("Date"),
           div(id="dates",
               
               # Some introductory text:
               p("If the report only contains vague information regarding the start or end date, please have a look at the codebook and coding instructions, code the earliest day possible and use the precision variable to specify the range of start and end dates."),
               
               hidden( # This is only shown when coders select "Unknown" for the year (see server function for this functionality):
                 div(id="dateMis",
                     h4("If it is unclear in which year the event took place, please tick the box for too much missing information above, save and proceed."))
               ),
               hidden( # This is only shown when coders select "Outside period" for the year (see server function for this functionality):
                 div(id="dateOut",
                     h4("If the start date is does not lie within our period of interest (see above), please save and proceed with next event or text."))
               ),
               
               # Entry variables:
               selectInput("year_start", "Start year", c("None selected","Outside period","Unknown",as.character(1919:1939))),
               selectInput("month_start", "Start month", c("None selected","Unknown","1: January","2: February","3: March","4: April","5: May",
                                                           "6: June","7: July","8: August","9: September","10: October",
                                                           "11: November","12: December")),
               selectInput("day_start", "Start day", c("None selected","Unknown",paste0("0",as.character(1:9)),as.character(10:31))),
               radioButtons("start_date_prec", "Precision (start date)", 
                            choices=c("1: exact date","2: 2-6 day range", "3: only week known", "4: only month known",
                                      "5: only year known", "6: no info"), selected = "6: no info"),
               checkboxInput("showEndDate", "The event lasted more than one day."),
               
               # The whole section about the end date is only shown when the coders check the showEndDate checkbox (see server function for this functionality):
               hidden(div(id="endDateSec",
                          p("The event lasted an unknown number of days (more than one)? Please code the end date as three days after the start date."),
                          selectInput("year_end", "End year", c("Same as start date","Unknown",as.character(1919:1939))),
                          selectInput("month_end", "End month", c("Same as start date","Unknown","1: January","2: February","3: March","4: April","5: May",
                                                                  "6: June","7: July","8: August","9: September","10: October",
                                                                  "11: November","12: December")),
                          selectInput("day_end", "End day", c("Same as start date","Unknown",paste0("0",as.character(1:9)),as.character(10:31))),
                          radioButtons("end_date_prec", "Precision (end date)", 
                                       choices=c("1: exact date","2: 2-6 day range", "3: only week known", "4: only month known",
                                                 "5: only year known", "6: no info"), selected = "6: no info")
               )))),
    
    
    # 2.3.3 Actor ####
    
    column(3, 
           h4("Actor"),
           div(id="actors",
               # One-sided or multi-sided violence?
               radioButtons("two_sided","Who used violence?",
                            choices=c("Only one side","More than one side","Don't know","None selected"),
                            selected="None selected"),
               # Actor A:
               selectInput(inputId="actor_a_group", "Actor A - Category",
                           choices = c("None selected","Unknown","Other (please specify below)"),
                           selected="None selected"), # Be aware that in the line above, we also select all actor categories saved in actorListExt.
               selectInput(inputId="actor_a", "Actor A - Organized group",
                           choices = c("None selected","Unknown"), # The actual list is defined in the server function in dependence on the actor category chosen.
                           selected="None selected"),
               hidden(div(id="actor_a_text", # This is only shown when the coder selects "Other" as actor a, see server function for the functionality itself.
                          textInput("actor_a_other",
                                    label="New actor: ",
                                    placeholder="Please specify name of actor"))),
               # Actor B (just the same as actor a in terms of code written):
               selectInput(inputId="actor_b_group", "Actor B - Category",
                           choices = c("None selected","Unknown","Other (please specify below)"),
                           selected="None selected"),
               selectInput(inputId="actor_b", "Actor B - (Organized) Group",
                           choices=c("None selected","Unknown"),
                           selected="None selected"),
               hidden(div(id="actor_b_text",
                          textInput("actor_b_other",
                                    label="New actor: ",
                                    placeholder="Please specify name of actor")))
           )
    ),
    
    # 2.3.4 Casualties ####
    
    column(3,
           h4("Casualties"),
           div(id="casualties",
               radioButtons("deaths_cat","Deaths mentioned?",
                            choices=c("No deaths mentioned", "Deaths mentioned", "Deaths likely","None selected"),
                            selected="None selected"),
               textInput("deaths","Numer of reported deaths",placeholder="as in the text, e.g. \"several\" or \"5\""),
               radioButtons("injured_cat", "Injuries mentioned?",
                            choices=c("No injuries mentioned","Injuries mentioned","Injuries likely","None selected"),
                            selected="None selected"),
               textInput("injured","Number of reported injured people",placeholder="as in the text, e.g. \"several\" or \"5\"")
               #radioButtons("armed", "Does the text mention any arms?",choices=c("Yes","No","Don't know"), selected="Don't know")
           ))),
  
  
  # 2.4 Consistency check ####
  # This defines the design of the section with the consistency check functionality.
  
  div(id="consist",
      h4("Consistency check"),
      htmlOutput("consText"), # What is shown here is defined in the sever function.
      actionButton("consCheck","Check consistency", class = "btn-primary")),
  
  
  # 2.5 Comments ####
  # This defines the design of the section where coders can leave comments.
  
  div(id="comment",
      h4("Additional comments"),
      textAreaInput("comments", "Comments: ", 
                    value="", placeholder="Leave NA if no comment necessary",
                    width='100%')),
  
  
  # 2.6 Saving and refreshing ####
  # This defines the design of the section in which coders can save and refresh the app.
  
  div(id="save",
      h4("Done coding and save"),
      p("If the", strong("\"Save data\" button is inactive"), "try the following things first:"),
      p("a) if you coded the article: Make sure you selected an article ID, clicked on \"Show on map\" and on \"Check consistency\". Follow potential instructions before saving."),
      p("b) if you did not code the article: Make sure you selected an article ID, either ticked that the article does not mention pol. violence, or that information is missing, and clicked on \"Check consistency\". Follow potential instructions before saving."),
      actionButton("savedat","Save data", class = "btn-primary"), # All the functionality of these buttons is defined below in the server function.
      actionButton("reloadapp", "Refresh app", class = "btn-primary"))
  
)))


# 3 Server function ####
# Finally, we define how the app shall react to anything the coders do.
server <- function(input, output, session) {
  
  # Enable password entry:
  res_auth <- secure_server(
    check_credentials = check_credentials(credentials),
    timeout=30
  )
  
  # 3.1 Newspaper section ####
  
  # Show newspapers based on countries:
  
  observe({
    updateSelectInput(session, "newspaper_select", "First, please select a newspaper:",
                         choices=c("None selected", 
                                   sort(newspaper_list$newspaper[newspaper_list$country==input$country_list])), 
                         selected="None selected")
  })
  
  observe({
    updateSelectInput(session, "actor_a_group", "Actor A - Category",
                      choices=c("None selected","Unknown","Other (please specify below)", 
                                sort(actor_list$actor_group[actor_list$country==input$country_list])), 
                      selected="None selected")
  })
  
  observe({
    updateSelectInput(session, "actor_b_group", "Actor B - Category",
                      choices=c("None selected","Unknown","Other (please specify below)",
                                sort(unique(actor_list$actor_group[actor_list$country==input$country_list]))), 
                      selected="None selected")
  })

  observeEvent(input$art_select,{
    if (input$year_start=="0") { show("artMis") }
    if (input$year_start!="0") { hide("dateMis") }
  })
  # 3.2 Map section ####
  
  # What the map should show in the beginning:
  output$europe <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%
      fitBounds(-25, 35, 65, 72) # europe limits (lat 35, 72, long -25, 65)
  })
  
  # What shall happen in the background once coders click on "Show on map":
  # First, the button needs to be disabled for at least 1 second so that we remain within the limits of queries we are allowd to make:
  observeEvent(input$showmap, {
    disable("showmap")
    delay(3000, enable("showmap")) # Now: it disables the button for 3 seconds.
  })
  # Than, we want the app to query OSM for the long and lat information:
  townQuery <- eventReactive(input$showmap, { # As a reaction to the click on the showmap button, ...
    if (input$region!="" | input$town!="" | input$town_locality!="" | input$street!="") { # ... paste all locality information into one string, ...
      geocode_osm(paste0(input$town, " ", input$region, " ", input$town_locality, " ", input$street),
                  user_agent = "bruno.dellasala@uni-wh.de") # ... and geo code this string.
    } else { # If there is no location mentioned but the country, just query the centroid of the country.
      geocode_osm(input$country, user_agent = "bruno.dellasala@uni-wh.de")
    }
  }
  )
  # Finally, use the geocode data from above to update the map:
  observe({
    townLng <- townQuery()$longitude # Extract long and lat data
    townLat <- townQuery()$latitude
    leafletProxy("europe") %>%
      clearMarkers() %>% # Clear potential old markers and ...
      addMarkers(lng=townLng, lat=townLat) # ... add new markers
  })
  
  # Finally, for the consistency check and to "force" coders to click on "Show on map" at least once, we need the following functionality:
  mapClicked <- reactiveVal(0) # Set a variable in the background that is 0 if nothing has happend, yet.
  observeEvent(input$showmap, { # If someone clicks on showmap, update the variable to be the number of times someone has clicked on showmap.
    mapClicked(input$showmap)
  })
  observeEvent(input$reloadapp,{ # Re-set the counter to zero once someone clicks on reloadapp / refreshes the app.
    mapClicked(0)
  }) # The counter will be used below for toggling the save button and for the consistency check warnings.
  # Do the same with the consistency check:
  consClicked <- reactiveVal(0)
  observeEvent(input$consCheck, {
    consClicked(input$consCheck) 
  })
  observeEvent(input$reloadapp, {
    consClicked(0)
  })
  
  # 3.3 Country section ####
  
  # Update notes / warnings / explanations on how to proceed shown based on the country selection:  
  observeEvent(input$country, {
    if (input$country=="None selected") {
      hide("noinfosec")
      show("dontcode")
    }
    
    if (input$country=="Not mentioned") {
      show("noinfosec")
      hide("dontcode")
    }
    
    if (input$outside==T) {
      hide("noinfosec")
      show("dontcode")
    }
    else { 
      hide("dontcode")
      hide("noinfosec")
    }
  })
  
  # 3.4 Date section ####
  
  # Update notes / warnings / explanations on how to proceed shown based on the start year selection:  
  observeEvent(input$year_start,{
    if (input$year_start=="Unknown") { show("dateMis") }
    if (input$year_start!="Unknown") { hide("dateMis") }
  })
  
  observeEvent(input$year_start, {
    if (input$year_start=="Outside period") { show("dateOut") }
    if (input$year_start!="Outside period") { hide("dateOut") }
  })
  
  # If someone indicates that the event lasted longer than one day, show the end-date variables to code:
  observeEvent(input$showEndDate, {
    if (input$showEndDate==T) { show("endDateSec") } # Show it, if the box is ticked.
    if (input$showEndDate==F) { # Delete any information previously entered and hide it if the box is not ticked.
      hide("endDateSec") 
      updateSelectInput(session, "day_end", "End day", 
                        c("Same as start date","Unknown",paste0("0",as.character(1:9)),as.character(10:31)))
      updateSelectInput(session, "month_end", "End month", 
                        c("Same as start date","Unknown","1: January","2: February","3: March","4: April","5: May",
                          "6: June","7: July","8: August","9: September","10: October",
                          "11: November","12: December"))
      updateSelectInput(session, "year_end", "End year", c("Same as start date","Unknown",as.character(1919:1939)))
      updateRadioButtons(session, "end_date_prec", "Precision (end date)", 
                         choices=c("1: exact date","2: 2-6 day range", "3: only week known", "4: only month known",
                                   "5: only year known", "6: no info"), 
                         selected = "6: no info")
    }
  })
  
  # 3.5 Actor section ####
  
  # Change possible set of organizations to choose from based on the actor group chosen:
  observeEvent(input$actor_a_group, {
    updateSelectInput(session, "actor_a", "Actor A - Organized group",
      choices=c("None selected","Unknown","Other (please specify below)",
      sort(unique(actor_list$actor[actor_list$actor_group[actor_list$country==input$country_list]==input$actor_a_group]))), 
      selected="None selected")
  })
  
  observeEvent(ignoreInit = TRUE, list(input$actor_a,input$actor_b), { # Show the text entry fields for new actors if Other is selected as actor:
    if (input$actor_a=="Other (please specify below)") { show("actor_a_text") }
    if (input$actor_a!="Other (please specify below)") { hide("actor_a_text") }
  })
  
  # Do the same again for actor group b and actor b:
  observeEvent(input$actor_b_group, {
    updateSelectInput(session, "actor_b", "Actor B - Organized group",
                      choices=c("None selected","Unknown","Other (please specify below)",
                                sort(unique(actor_list$actor[actor_list$actor_group[actor_list$country==input$country_list]==input$actor_b_group]))), 
                      selected="None selected")
  })
  
  observeEvent(ignoreInit = TRUE, list(input$actor_a,input$actor_b), { # Show the text entry fields for new actors if Other is selected as actor:
    if (input$actor_b=="Other (please specify below)") { show("actor_a_text") }
    if (input$actor_b!="Other (please specify below)") { hide("actor_a_text") }
  })
  
  # 3.6 Consistency check ####
  
  observeEvent(input$consCheck, {
    
    # Starting "position":
    allData <- "" # This is the baseline text shown: an empty text.
    
    # Condition 1: Select a value for every obligatory entry field.
    if ( input$country_list=="None selected" |
         input$newspaper_select=="None selected" |
         input$art_select=="0" |
         input$year=="None selected" |
         input$month=="None selected" |
         input$day=="None selected" |
         input$country=="None selected" |
         input$day_start=="None selected" | 
         input$month_start=="None selected" | 
         input$year_start=="None selected" | 
         input$actor_a_group=="None selected" |
         input$actor_a=="None selected" |
         input$actor_b_group=="None selected" |
         input$actor_b=="None selected" |
         input$two_sided=="None selected" |
         input$deaths_cat=="None selected" |
         input$injured_cat=="None selected"
    ) {
      allData <- paste(allData,"<p><span style=\"color:red\">Please select an option for each variable where it still reads \"None selected\".</span></p>",
                       collapse = " ") # Add to the baseline text a warning if the condition is met.
    }
    
    # For next steps, calculate startDate and endDate:
    year_start <- gsub(pattern="\\D",x=input$year_start,replacement="")
    month_start <- gsub(pattern="\\D",x=input$month_start,replacement="")
    day_start <- gsub(pattern="\\D",x=input$day_start,replacement="")
    year_end <- gsub(pattern="\\D",x=input$year_end,replacement="")
    month_end <- gsub(pattern="\\D",x=input$month_end,replacement="")
    day_end <- gsub(pattern="\\D",x=input$day_end,replacement="")
    startDate <- paste0(year_start,month_start,day_start)
    endDate <- paste0(year_end,month_end,day_end)
    
    # Condition 2: End date not larger than start date.
    if ( input$year_start!="None selected" & input$year_start!="Unknown" & 
         input$year_end!="None selected" & input$year_end!="Unknown" & input$year_end!="Same as start date" &
         startDate > endDate
    ) {
      allData <- paste(allData,"<p><span style=\"color:red\"> The start date you entered seems to be after the end date you entered.</span></p>",
                       collapse=" ")
    }
    
    # Condition 3: Logical date format, e.g. no month, but day entered etc.
    # For start date:
    if (year_start=="" & (month_start!="" | day_start!="") |
        month_start=="" & day_start!="") {
      allData <- paste(allData,"<p><span style=\"color:red\">Your start date seems incomplete. Please check, e.g. whether you entered a day but not a month or a month but not a year.</span></p>",
                       collapse=" ")
    }
    if ( (day_start>29 & month_start==2) |
         (day_start>30 & month_start%in%c(4,6,9,11)) ) {
      allData <- paste(allData,"<p><span style=\"color:red\">Your state date indicates a day in a month that does not exist (e.g. 31st of April).</span></p>",
                       collapse=" ")
    }
    
    # For end date:
    if (year_end=="" & (month_end!="" | day_end!="") |
        month_end=="" & day_end!="") {
      allData <- paste(allData,"<p><span style=\"color:red\">Your end date seems incomplete. Please check, e.g. whether you entered a day but not a month or a month but not a year.</span></p>",
                       collapse=" ")
    }
    if ( (day_end>29 & month_end==2) |
         (day_end>30 & month_end%in%c(4,6,9,11)) ) {
      allData <- paste(allData,"<p><span style=\"color:red\">Your end date indicates a day in a month that does not exist (e.g. 31st of April or 30th of February).</span></p>",
                       collapse=" ")
    }
    
    # For end date only partially "Same as start date":
    if ( (input$year_end!="Same as start date" & input$month_end=="Same as start date") |
         (input$year_end=="Same as start date" & input$month_end!="Same as start date") |
         (input$day_end!="Same as start date" & input$month_end=="Same as start date") |
         (input$day_end=="Same as start date" & input$month_end!="Same as start date") |
         (input$day_end!="Same as start date" & input$year_end=="Same as start date") |
         (input$day_end=="Same as start date" & input$year_end!="Same as start date") ) {
      allData <- paste(allData,"<p><span style=\"color:red\">Please correct your end date: Not all / some variables still are specified as \"Same as start date\".</span></p>",
                       collapse=" ")
    }
    # For end date "Same as start date" if longer than one day:
    if ( (input$year_end=="Same as start date" | input$month_end=="Same as start date" | input$day_end=="Same as start date") & 
         input$showEndDate==T) {
      allData <- paste(allData,"<p><span style=\"color:red\">You have indicated that the event lasted longer than one day <i>and</i> that the event ended on the same day as it started.</span></p>",
                       collapse=" ")
    }
    
    # Condition 4: Enter 0 if no injured and dead are reported
    if ( input$deaths=="" | input$injured=="" ) {
      allData <- paste(allData,"<p><span style=\"color:red\">If no injured people or nor dead are reported, please enter \"0\" into the respective text fields.</span></p>",
                       collapse=" ")
    }
    
    # Condition 5: Remind them to push "Show on map" to actually get latitude and longitude
    if  (mapClicked()==0) {
      allData <- paste(allData,"<p><span style=\"color:red\">Please click at least once on \"Show on map\" to generate geo coordinates in the background.</span></p>",
                       collapse=" ")
    }
    
    
    # Condition 6: Not enough information or no political violence correctly specified:
    # If article does not mention political violence:
    if (input$novio==TRUE) {
      allData <- paste(allData,"<p><span style=\"color:orange\">You have indicated that the article does not mention any political violence. If that is correct, please ignore red messages, save and proceed. Otherwise, please correct your coding.</span></p>",
                       collapse=" ")
    }
    if (input$missinginfo==TRUE) {
      allData <- paste(allData,"<p><span style=\"color:orange\">You have indicated that the article does not contain enough information to be coded. If that is correct, please ignore red messages, save and proceed. Otherwise, please correct your coding.</span></p>",
                       collapse=" ")
    }
    
    # If articles mentions political violence outside Europe.
    if (input$country=="None selected" | input$country=="Not mentioned") {
      allData <- paste(allData,"<p><span style=\"color:orange\">You have indicated that the report mentions political violence <b>outside the territory of interest</b>. If that is correct, please ignore red messages, save and proceed. Otherwise, please correct your coding as suggested.</span></p>",
                       collapse=" ")
    }
    
    # If articles mentions political violence outside period of interest.
    if (input$year_start %in% c("Outside period")) {
      allData <- paste(allData,"<p><span style=\"color:orange\">You have indicated that the report mentions political violence <b>outside the period of interest</b>. If that is correct, please ignore red messages, save and proceed. Otherwise, please correct your coding as suggested.</span></p>",
                       collapse=" ")
    }
    
    # If missing information not ticked but not enough information provided.
    if (input$missinginfo==FALSE & input$actor_a_group=="Unknown" & input$actor_b_group=="Unknown") {
      allData <- paste(allData,"<p><span style=\"color:red\">You have indicated that the report does not mention <b> any </b> involved actors but not ticked the box for too much missing information above.</span></p>",
                       collapse=" ")
    }
    if (input$missinginfo==FALSE & input$year_start=="Unknown") {
      allData <- paste(allData,"<p><span style=\"color:red\">You have indicated that the report does not mention the start year but not ticked the box for too much missing information above.</span></p>",
                       collapse=" ")
    }
    if (input$missinginfo==FALSE & input$country=="Not mentioned") {
      allData <- paste(allData,"<p><span style=\"color:red\">You have indicated that the report does not mention the country but not ticked the box for too much missing information above.</span></p>",
                       collapse=" ")
    }
    
    # Condition 7: Deaths mentioned but none entered, similarly: injured
    if ( (input$deaths_cat=="Deaths mentioned" | input$deaths_cat=="Deaths likely") &
         input$deaths=="" ) {
      allData <- paste(allData, "<p><span style=\"color:red\">You have indicated that the report mentiones (likely) deaths. Please copy past the respective description into the field \"Number of reported deaths\"</span></p>.",
                       collapse=" ")
    }
    
    if ( (input$injured_cat=="Injuries mentioned" | input$injured_cat=="Injuries likely") &
         input$injured=="" ) {
      allData <- paste(allData, "<p><span style=\"color:red\">You have indicated that the report mentiones (likely) injured people. Please copy past the respective description into the field \"Number of reported injured people\"</span></p>.",
                       collapse=" ")
    }
    
    # Condition 8: No deaths mentioned, but some entered, similarly: injured
    if ( (input$deaths_cat=="No deaths mentioned") &
         input$deaths!="0" ) {
      allData <- paste(allData, "<p><span style=\"color:red\">You have indicated that the report <b>does not</b> mentione any deaths but the entry field for the number reported deaths is <b>not</b> 0. Please code the number of reported deaths as 0 if there were not, or indicate that deaths were likely or mentioned.</span></p>",
                       collapse=" ")
    }
    
    if ( (input$injured_cat=="No injuries mentioned") &
         input$injured!="0" ) {
      allData <- paste(allData, "<p><span style=\"color:red\">You have indicated that the report <b>does not</b> mentione any injuries but the entry field for the number reported injured people is <b>not</b> 0. Please code the number of reported injured people as 0 if there were none, or indicate that injuries were likely or mentioned.</span></p>",
                       collapse=" ")
    }
    
    
    # Condition 9: Everything is fine 
    # If everything is fine / none of the conditions is met, replace the empty message completely with the following message:
    if (allData=="") {
      allData <- "<p><span style=\"color:green\">Well done. The data you entered seems to be consistent.</span></p>"
    }
    
    output$consText <- renderText(allData) # Show the text in the app itself
    
  })
  
  
  # 3.7 Build data set in the background and save ####
  
  # Only allow this if consistency check has been clicked at least once!
  # Activate the button if 
  # a) consCheck and mapClicked have been clicked and ID has been selected
  # b) consCheck has been clicked and (novio or missinginfo have been ticked) and ID has been selected
  observe({ 
    toggleState("savedat", condition = consClicked()>0 & mapClicked()>0 & input$newspaper_select!="None selected" |
                  (consClicked()>0 & (input$novio==T | input$missinginfo==T) & input$newspaper_select!="None selected") )
  })
  
  # Create data set:
  observeEvent(input$savedat, { 
    
    showNotification("Please wait. Your data is being collected and transformed into a data set.") # Show this directly at the beginning.
    
    # Create the data set itself:
    data <- sapply(fieldsAll, function(x) input[[x]]) # Extract all input vars into one object
    # fieldsAll has been defined above and lists the column names / var names of interest
    data <- t(data) # transpose the object
    data <- data.frame(data, stringsAsFactors = F) # make the object a data frame
    data <- purrr::map_dfc(data, function(x) if (sum(lengths(x))>length(a)) {
      lapply(x, function(y) paste0(y, collapse = "|"))
    } else {
      x
    }
    ) # To be honest, I forgot what this does but it is important. 
    # One of these things that is hard to test outside the shiny app since the input is created by the app itself...
    
    # Also add longitude and latitude from the OSM query:
    data$town_ln <- ifelse(input$novio!=TRUE & input$missinginfo!=TRUE,
                           townQuery()$longitude, "")
    data$town_lat <- ifelse(input$novio!=TRUE & input$missinginfo!=TRUE,
                            townQuery()$latitude, "")
    data$country_coded <- input$country_list # as well as the country supposed to be coded
    
    data$coder <- res_auth$user # and the coder name
    
    data$newspaper <- input$newspaper_select
    # Update the actorList if new actors have been added:
    if (input$actor_a=="Other (please specify below)") {
      newActors <- data.frame(country=input$country_list,
                              actor_group=input$actor_a_group,
                              actor=input$actor_a_other)
      actorListExt <- rbind(actorListExt,newActors)
    }
    
    if (input$actor_b=="Other (please specify below)") {
      newActors <- data.frame(country=input$country_list,
                              actor_group=input$actor_b_group,
                              actor=input$actor_b_other)
      actorListExt <- rbind(actorListExt,newActors)
      actorListExt <- unique(actorListExt)
    }
    
    # Save data as csv and upload files to the dropbox:
    
    fileName <- sprintf("%s_%s_%s_%s.csv", # Create a unique file name
                        input$country_list, # Specify the country coded
                        input$newspaper_select, # Specify the newspaper
                        Sys.time(), # Specify the time and date when the file was saved
                        res_auth$user) # Add the coder name
    write.csv(x=data, # Write the csv file to the coders' local temp folder
              file=file.path(tempdir(), fileName),
              row.names = F,
              quote = T,
              fileEncoding="UTF-8",
              na="")
    
    if (input$actor_a=="Other (please specify below)" | input$actor_b=="Other (please specify below)") {
      actorListName <- sprintf("%s_%s.csv",
                               "actorList",
                               Sys.time())
      write.csv(x=actor_list,
                file=file.path(tempdir(), actorListName),
                row.names = F,
                quote = T,
                fileEncoding="UTF-8",
                na="")
    }
    
    # Since all data has been created and stored locally, show the following message:
    showNotification("Your data is being uploaded. This can take a while.") 
    
    drop_upload(file=file.path(tempdir(), fileName), # Upload the temporary files to the Dropbox
                path=dropboxPath_final, 
                mode="add",
                dtoken = token)
    if (input$actor_a=="Other (please specify below)" | input$actor_b=="Other (please specify below)") {
      drop_upload(file=file.path(tempdir(), actorListName), 
                  path="22-2-InterwarViolence/shiny_generalapp/data_input/", 
                  mode="add",
                  dtoken = token)
    }
    
    # Show the following message after everything has been uploaded:
    showNotification("Your data has been saved and uploaded successfully.")
    
  })
  
  # 3.8  Refresh app #####
  # Reset everything to the baseline codition as if nothing had been done before once coders click on reloadapp.
  
  observeEvent(input$reloadapp, {
    
    output$europe <- renderLeaflet({
      leaflet() %>%
        addTiles() %>%
        fitBounds(-25, 35, 65, 72)
    })
    
    updateSelectInput(session, inputId="country_list", selected=c("None selected"))
    updateSelectInput(session, inputId="newspaper_select", selected=c("None selected"))
    updateSelectInput(session, inputId="art_select", selected=c("0"))
    updateSelectInput(session, inputId="day", selected=c("None selected"))
    updateSelectInput(session, inputId="month", selected=c("None selected"))
    updateSelectInput(session, inputId="year", selected=c("None selected"))
    updateSelectInput(session, inputId="country", selected=c("None selected"))
    updateSelectInput(session, inputId="day_start", selected=c("None selected"))
    updateSelectInput(session, inputId="month_start", selected=c("None selected"))
    updateSelectInput(session, inputId="year_start", selected=c("None selected"))
    updateSelectInput(session, inputId="day_end", selected=c("Same as start date"))
    updateSelectInput(session, inputId="month_end", selected=c("Same as start date"))
    updateSelectInput(session, inputId="year_end", selected=c("Same as start date"))
    updateSelectInput(session, inputId="actor_a_group", selected=c("None selected"))
    updateSelectInput(session, inputId="actor_b_group", selected=c("None selected"))
    
    updateCheckboxInput(session, inputId="novio",value=FALSE)
    updateCheckboxInput(session, inputId="missinginfo",value=FALSE)
    updateCheckboxInput(session, inputId="outside",value=FALSE)
    updateCheckboxInput(session, inputId="mapfine",value=FALSE)
    updateRadioButtons(session, inputId="start_date_prec",selected="6: no info")
    updateRadioButtons(session, inputId="end_date_prec",selected="6: no info")
    updateCheckboxInput(session, inputId="showEndDate",value=FALSE)
    updateRadioButtons(session, inputId="two_sided",selected="None selected")
    updateRadioButtons(session, inputId="deaths_cat",selected="None selected")
    updateRadioButtons(session, inputId="injured_cat",selected="None selected")
    
    updateTextInput(session, inputId="region",value=NA)
    updateTextInput(session, inputId="town",value=NA)
    updateTextInput(session, inputId="town_locality",value=NA)
    updateTextInput(session, inputId="street",value=NA)
    #updateTextInput(session, inputId="long",value=NA)
    #updateTextInput(session, inputId="lat",value=NA)
    updateTextInput(session, inputId="actor_a_other",value=NA)
    updateTextInput(session, inputId="actor_b_other",value=NA)
    updateTextInput(session, inputId="deaths",value=NA)
    updateTextInput(session, inputId="injured",value=NA)
    updateTextAreaInput(session, inputId="comments",value=NA)
    
    disable("savedat")
    output$consText <- renderText("")
  })
  
}


# 4 Build shiny app ####
# Run the application 
shinyApp(ui = ui, 
         server = server)

